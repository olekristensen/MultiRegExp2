{"version":3,"sources":["../src/multiRegExp2.js"],"names":["addGroupToRegexString","str","start","end","groupsAdded","substring","fillGroups","regex","regexString","modifier","source","flags","toString","lastIndexOf","substr","tester","modifiedRegex","lastGroupStartPosition","lastGroupEndPosition","lastNonGroupStartPosition","lastNonGroupEndPosition","groupCount","matchArr","nonGroupPositions","groupPositions","groupNumber","currentLengthIndexes","groupIndexMapper","previousGroupsForGroup","exec","index","length","push","lastGroupPosition","Math","max","slice","pop","regexp","RegExp","MultiRegExp2","baseRegExp","string","includeFullMatch","matches","prototype","call","firstIndex","indexMapper","Object","assign","previousGroups","keys","map","group","mapped","r","match","reduce","sum","i"],"mappings":"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","file":"multiRegExp2.js","sourcesContent":["/**\n * Created by velten on 11.02.17.\n */\n\n/**\n * Adds brackets before and after a part of string\n * @param str string the hole regex string\n * @param start int marks the position where ( should be inserted\n * @param end int marks the position where ) should be inserted\n * @param groupsAdded int defines the offset to the original string because of inserted brackets\n * @return {string}\n */\nfunction addGroupToRegexString(str, start, end, groupsAdded) {\n  start += groupsAdded * 2;\n  end += groupsAdded * 2;\n  return str.substring(0, start) + '(' + str.substring(start, end + 1) + ')' + str.substring(end + 1);\n}\n\n/**\n * converts the given regex to a regex where all not captured string are going to be captured\n * it along sides generates a mapper which maps the original group index to the shifted group offset and\n * generates a list of groups indexes (including new generated capturing groups)\n * which have been closed before a given group index (unshifted)\n *\n * Example:\n * regexp: /a(?: )bc(def(ghi)xyz)/g => /(a(?: )bc)((def)(ghi)(xyz))/g\n * groupIndexMapper: {'1': 2, '2', 4}\n * previousGroupsForGroup: {'1': [1], '2': [1, 3]}\n *\n * @param regex RegExp\n * @return {{regexp: RegExp, groupIndexMapper: {}, previousGroupsForGroup: {}}}\n */\nfunction fillGroups(regex) {\n  let regexString;\n  let modifier;\n  if (regex.source && regex.flags) {\n    regexString = regex.source;\n    modifier = regex.flags;\n  }\n  else {\n    regexString = regex.toString();\n    modifier = regexString.substring(regexString.lastIndexOf(regexString[0]) + 1); // sometimes order matters ;)\n    regexString = regexString.substr(1, regex.toString().lastIndexOf(regexString[0]) - 1);\n  }\n  // regexp is greedy so it should match (? before ( right?\n  // brackets may be not quoted by \\\n  // closing bracket may look like: ), )+, )+?, ){1,}?, ){1,1111}?\n\tconst tester = /(\\\\\\()|(\\\\\\))|(\\(\\?)|(\\()|(\\)(?:\\{\\d+,?\\d*}|[*+?])?\\??)/g;\n\n  let modifiedRegex = regexString;\n\n  let lastGroupStartPosition = -1;\n  let lastGroupEndPosition = -1;\n  let lastNonGroupStartPosition = -1;\n  let lastNonGroupEndPosition = -1;\n  let groupsAdded = 0;\n  let groupCount = 0;\n  let matchArr;\n  const nonGroupPositions = [];\n  const groupPositions = [];\n  const groupNumber = [];\n  const currentLengthIndexes = [];\n  const groupIndexMapper = {};\n  const previousGroupsForGroup = {};\n  while ((matchArr = tester.exec(regexString)) !== null) {\n    if(matchArr[1] || matchArr[2]) { // ignore escaped brackets\n\n    }\n    if (matchArr[3]) { // non capturing group\n      let index = matchArr.index + matchArr[0].length - 1;\n\n      lastNonGroupStartPosition = index;\n      nonGroupPositions.push(index);\n    }\n    else if (matchArr[4]) { // capturing group\n      let index = matchArr.index + matchArr[0].length - 1;\n\n      let lastGroupPosition = Math.max(lastGroupStartPosition, lastGroupEndPosition);\n\n      // if a (? is found add ) before it\n      if(lastNonGroupStartPosition > lastGroupPosition) {\n        modifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupPosition + 1, lastNonGroupStartPosition - 2, groupsAdded);\n        groupsAdded++;\n        lastGroupEndPosition = lastNonGroupStartPosition - 1; // imaginary position as it is not in regex but modifiedRegex\n        currentLengthIndexes.push(groupCount + groupsAdded);\n\n        // if necessary also add group between (? and opening bracket\n        if(index > lastNonGroupStartPosition + 2) {\n          modifiedRegex = addGroupToRegexString(modifiedRegex, lastNonGroupStartPosition + 2, index - 1, groupsAdded);\n          groupsAdded++;\n          lastGroupEndPosition = index - 1; // imaginary position as it is not in regex but modifiedRegex\n          currentLengthIndexes.push(groupCount + groupsAdded);\n        }\n      }\n      else if (lastGroupPosition < index - 1) {\n        modifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupPosition + 1, index - 1, groupsAdded);\n        groupsAdded++;\n        lastGroupEndPosition = index - 1; // imaginary position as it is not in regex but modifiedRegex\n        currentLengthIndexes.push(groupCount + groupsAdded);\n      }\n\n      groupCount++;\n      lastGroupStartPosition = index;\n      groupPositions.push(index);\n      groupNumber.push(groupCount + groupsAdded);\n      groupIndexMapper[groupCount] = groupCount + groupsAdded;\n      previousGroupsForGroup[groupCount] = currentLengthIndexes.slice();\n    }\n    else if (matchArr[5]) { // closing bracket\n      let index = matchArr.index + matchArr[0].length - 1;\n\n      if ((groupPositions.length && !nonGroupPositions.length) ||\n        groupPositions[groupPositions.length - 1] > nonGroupPositions[nonGroupPositions.length - 1]\n      ) {\n        if (lastGroupStartPosition < lastGroupEndPosition && lastGroupEndPosition < index - 1) {\n          modifiedRegex = addGroupToRegexString(modifiedRegex, lastGroupEndPosition + 1, index - 1, groupsAdded);\n          groupsAdded++;\n          //lastGroupEndPosition = index - 1; will be set anyway\n          currentLengthIndexes.push(groupCount + groupsAdded);\n        }\n\n        groupPositions.pop();\n        lastGroupEndPosition = index;\n        currentLengthIndexes.push(groupNumber.pop());\n      }\n      else if (nonGroupPositions.length) {\n        nonGroupPositions.pop();\n        lastNonGroupEndPosition = index;\n      }\n    }\n  }\n\n  return {regexp: new RegExp(modifiedRegex, modifier), groupIndexMapper, previousGroupsForGroup};\n}\n\nexport default class MultiRegExp2 {\n  constructor(baseRegExp) {\n    const {regexp, groupIndexMapper, previousGroupsForGroup} = fillGroups(baseRegExp);\n    this.regexp = regexp;\n    this.groupIndexMapper = groupIndexMapper;\n    this.previousGroupsForGroup = previousGroupsForGroup;\n  }\n\n  execForAllGroups(string, includeFullMatch) {\n    let matches = RegExp.prototype.exec.call(this.regexp, string);\n    if (!matches) return matches;\n    let firstIndex = matches.index;\n    let indexMapper = includeFullMatch ? this.groupIndexMapper : Object.assign({0: 0}, this.groupIndexMapper);\n    let previousGroups = includeFullMatch ? this.previousGroupsForGroup : Object.assign({0: []}, this.previousGroupsForGroup);\n\n    return Object.keys(indexMapper).map((group) => {\n      let mapped = indexMapper[group];\n      let r = {\n        match: matches[mapped],\n        start: firstIndex + previousGroups[group].reduce(\n          (sum, i) => sum + (matches[i] ? matches[i].length : 0), 0\n        )\n      };\n      r.end = r.start + (matches[mapped] ? matches[mapped].length : 0);\n\n      return r;\n    });\n  }\n\n  execForGroup(string, group) {\n    const matches = RegExp.prototype.exec.call(this.regexp, string);\n    if (!matches) return matches;\n    const firstIndex = matches.index;\n\n    const mapped = group == 0 ? 0 : this.groupIndexMapper[group];\n    const previousGroups = group == 0 ? [] : this.previousGroupsForGroup[group];\n    let r = {\n      match: matches[mapped],\n      start: firstIndex + previousGroups.reduce(\n        (sum, i) => sum + (matches[i] ? matches[i].length : 0), 0\n      )\n    };\n    r.end = r.start + (matches[mapped] ? matches[mapped].length : 0);\n\n    return r;\n  }\n}"]}